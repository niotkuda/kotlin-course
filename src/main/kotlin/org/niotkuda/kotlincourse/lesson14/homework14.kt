package org.niotkuda.kotlincourse.lesson14

fun main(){

        //1/ Дан словарь с именем и временем выполнения каждого автоматизированного теста в секундах.
        // Определите среднее время выполнения теста.

        val test1 = mapOf<String, Int>("first" to 10, "second" to 11, "third" to 12)
        println(test1.values.average())


        //2/ Имеется словарь с метаданными автоматизированных тестов,
        // где ключи — это имена тестовых методов\
        // а значения - строка с метаданными.
        // Выведите список всех тестовых методов.

        val test2 = mutableMapOf<String, String>("test2" to "metadata", "test2" to "metadata2")
        println(test2.keys.toList())


        //3/ В изменяемый словарь с данными о прохождении тестов добавьте
        // новый тест и его результат.

        val test3 = mutableMapOf("test1" to "done", "test2" to "notdone")
    test3 += "test3" to "done"
        println(test3)


        //4/ Посчитайте количество успешных тестов в словаре с результатами.

        println(test3.count { it.value == "done" })


        //5/ Удалите из изменяемого словаря с баг-трекингом запись о баге, который был исправлен.

val test5 = mutableMapOf<String, String>()
    test5.remove("done")

        //6/ Для словаря с результатами тестирования веб-страниц
        // (ключ — URL страницы, значение — статус ответа),
        // выведите сообщение о странице и статусе её проверки




    //7/ Найдите в словаре с названием и временем ответа сервисов только те,
    // время ответа которых превышает заданный порог.

        val test7 = mapOf("google" to 5, "youtube" to 50, "github" to 500)
        println(test7.filterValues { it > 100 })


        //8/ В словаре хранятся результаты тестирования API
    // (ключ — endpoint, значение — статус ответа в строке).
        // Для указанного endpoint найдите статус ответа,
    // если endpoint отсутствует, предположите, что он не был протестирован.

        val test8 = mapOf("endpoint" to "OK", "endpoint1" to "OK")

     //9/ Из словаря, содержащего конфигурации тестового окружения
    // (ключ — название параметра конфигурации),
    // получите значение для "browserType". Ответ не может быть null.

        val test9 = mapOf("browserType" to null)
        println(test9.getOrElse("browserType") { "ошибка" })


    //10/ Создайте копию неизменяемого словаря с данными о версиях тестируемого ПО,
    // чтобы добавить новую версию.
        val test10 = mapOf("Windows" to "1", "MacOS" to "1")
        val test10New = test10 + ("Linux" to "1")
        println(test10New)


     //11/ Используя словарь с настройками тестирования для различных мобильных устройств
    // (ключ — модель устройства),
        // получите настройки для конкретной модели или верните настройки по умолчанию.
        val test11 = mapOf("iphone" to "smth", "samsung" to "smth2", "lg" to "smth3")
        println(test11.getOrDefault("samsung", "smth4"))


    //12/ Проверьте, содержит ли словарь с ошибками тестирования
    // (код и описание) определенный код ошибки.
        val test12 = mapOf("mistake" to "mistake2")
        println(test12.containsKey("mistake"))
        println(test12.containsKey("mistake2"))


 //13/ Дан неизменяемый словарь, где ключи — это идентификаторы тестовых сценариев в формате
// "TestID_Version",
// а значения — статусы выполнения этих тестов ("Passed", "Failed", "Skipped").
        // Отфильтруйте словарь, оставив только те сценарии,
// идентификаторы которых соответствуют определённой версии тестов.
//val test13 = mapOf()

//14/У вас есть словарь, где ключи — это названия функциональных модулей приложения,
//    а значения — результаты их тестирования.
//    Проверьте, есть ли модули с неудачным тестированием.
//



//15/Добавьте в изменяемый словарь с настройками тестовой среды настройки из другого словаря.

val test15 = mutableMapOf<String, String>()
    test15.putAll(test5)

//
//16/Объедините два неизменяемых словаря с данными о багах.

val firstTest16 = mapOf (
    1 to "mistake1",
    2 to "mistake2"
)
    val secondTest16 = mapOf (
        3 to "mistake3",
       4 to "mistake4"
    )

val allTest16= firstTest16 + secondTest16

//
//17/Очистите изменяемый словарь с временными данными о последнем прогоне автоматизированных тестов.

    val test17 = mutableMapOf(
        "test1" to "temporary data1",
        "test2" to "temporary data2",
        "test3" to "temporary data3"
    )
test17.clear()
    println(test17)
//
//18/Исключите из отчета по автоматизированному тестированию те случаи,
//    где тесты были пропущены (имеют статус “skipped”)
//


//19/Удалите из словаря с конфигурациями тестирования набор устаревших конфигураций.
//


//20/Создайте отчет о тестировании, преобразовав словарь с результатами тестирования
//    (ключ — идентификатор теста, значение — результат) в список строк формата "Test ID: результат".
//

//21/Преобразуйте изменяемый словарь с результатами последнего тестирования в неизменяемый для архивации.
//


//22/Преобразуйте словарь, содержащий ID теста и данные о времени выполнения тестов,
// заменив идентификаторы тестов на их названия
// (название можно получить вызвав фейковый метод, например getNameById(id: String))
//


//23/Для словаря с оценками производительности различных версий приложения увеличьте каждую оценку на 10%,
// чтобы учесть новые условия тестирования.
//
val test23 = mutableMapOf<String, Int>()
    test23.mapValues { it.value *1.10 }

//24/Проверьте, пуст ли словарь с ошибками компиляции тестов.
//
val test24 = mapOf<Int, String>()
test24.isEmpty()

//25/Убедитесь, что словарь с результатами нагрузочного тестирования не пуст.
//

    val test25 = mapOf<Int, String>()
test25.isNotEmpty()

//26/Проверьте, прошли ли успешно все автоматизированные тесты в словаре с результатами.
//


//27/Определите, содержит ли словарь с результатами тестирования хотя бы один тест с ошибкой.
//

//28/Отфильтруйте словарь с результатами тестирования сервисов,
// оставив только те тесты, которые не прошли успешно и содержат в названии “optional”.
//

}