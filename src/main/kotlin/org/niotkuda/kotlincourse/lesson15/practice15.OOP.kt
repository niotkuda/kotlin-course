package org.niotkuda.kotlincourse.lesson15


// ООП объектно ориентированное программирование.



//ООП парадигма программирования, которая использует объекты для моделирования данных и поведения программы
//Основные концепты ООП включают КЛАССЫ И ОБЪЕКТЫ НАСЛЕДОВАНИЯ, ИНКАПСУЛЯЦИЮ, ПОЛИМОРФИЗМ, АБСТРАКЦИЮ
//
//
//

// КЛАСС в ООП определяется как шаблон или чертёж,
// который описывает состояние и поведение,
// которым обладает объект этого класса
// КЛАСС ЧЕРТЁЖ, ШАБЛОН описывает какие данные в будущем будет хранить объект, какие поля
// какие методы, какие действия этот объект может выполнять.
//Класс сам по себе ничего не производит, не хранит, не выполняет
//
//ОБЪЕКТ это ЭКЗЕМПЛЯР класса
//ЭКЗЕМПЛЯР это если класс это какой-то чертёж,
// потом этот чертёж отдаём на производство и там создают какой-то объект по этому чертежу
// (например ааавтомобиль) это экземпляр чертежа, экземпляр класса
//
//Когда класс определен, т.е начерчен,
// ни один из его методов или переменных не используется
// пока не будет создан объект этого класса
//
//Объекты создаются и уничтожаются, динамические могут иметь
// множество экземпляров одного класса
//Берём один чертёж и можем тамповать сколько угодно объектов из этого чертежа
// и это будут самостоятельные объекты между собой не связанные
//
//Каждый объект индивидуален, но обладает всеми характеристиками определёнными в классе
//Класс состоит из 2 сущностей (на данном этапе нашего погружения)
// состоит из полей(переменные, данные, состояние данных (какое значение хранится в поле,
// напр. пустая строка, булево значение)
//
//Объект может хранить состояние, оно же данные, оно же переменные
// объект обладает возможностью что-то делать, какими-то действиями, они же функции
// Функция=действие. Функция должна что-то делать, оно же метод
//
//ОБЪЕКТ МОЖЕТ ХРАНИТЬ ДАННЫЕ И ВЫПОЛНЯТЬ КАКИЕ-ТО ДЕЙСТВИЯ






fun main() {
    val person = Person("John", 30)
    person.sayHello()
}


// КЛАСС. По названию мы должны понимать что этот класс делает, какие данные он может хранить
// дальше в () присутствуют поля класса Внутри () определяем переменные.
// здесь мы их только объявляем, инициализировать не будем(присваивать им какие-то данные)
// Мы здесь показываем на чертеже какие данные объект будущий будет хранить.

// в данном случае будет хранить имя персоны и возраст
// Котлин позволяет хранить много классов в одном файле,
// но рекомендуется создавать отдельные классы


class Person(
    val name: String,
    var age: Int
) {                               //теперь к классу можем обратиться из другого файла (в этом пакете??)

    // person(age = 30, name = "John") котлин позволяет указывать аргументы через указание имени аргумента
    // если мы аргументы не прописываем, то нужно соблюсти порядок полей. name 1, age 2 тогда аргументы не нужно указывать
    // в большинстве случаев аргументы не указываем они захламляют код. Главное порядок их вызова соблюдать
//класс позволяет установить дефолтное значение для аргумента

    //чем отличается аргумент от переменной
    // аргумент мы будем использовать в функции, а в классе поля 00:50 (конструкторы методы)



    // Метод класса. Метод что-то выполняет
    fun sayHello() {
        println("Hello, my name is $name and I am $age years old.")
    }
}

object Logger {

    fun log(message: String) {
        println("Log: $message")
    }
}

class Calculator {
    companion object {
        fun add(a: Int, b: Int): Int {
            return a + b
        }
    }
}


//    val result = Calculator.add(5, 3)
//    println("Result: $result")
//}
//data class User(val id: Int, val name: String)
//
